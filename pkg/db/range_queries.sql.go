// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: range_queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRanges = `-- name: CountRanges :one
SELECT COUNT(*) 
FROM ranges 
WHERE service_id = $1
    AND ($2::range_status IS NULL OR status = $2::range_status)
    AND ($3::text IS NULL OR region = $3)
`

type CountRangesParams struct {
	ServiceID    string          `json:"service_id"`
	StatusFilter NullRangeStatus `json:"status_filter"`
	RegionFilter pgtype.Text     `json:"region_filter"`
}

// Counts total ranges for a service
func (q *Queries) CountRanges(ctx context.Context, arg CountRangesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRanges, arg.ServiceID, arg.StatusFilter, arg.RegionFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRange = `-- name: CreateRange :one
INSERT INTO ranges (
    start_id,
    end_id,
    service_id,
    region,
    status
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at
`

type CreateRangeParams struct {
	StartID   int64       `json:"start_id"`
	EndID     int64       `json:"end_id"`
	ServiceID string      `json:"service_id"`
	Region    pgtype.Text `json:"region"`
	Status    RangeStatus `json:"status"`
}

// Creates a new range allocation for a service
func (q *Queries) CreateRange(ctx context.Context, arg CreateRangeParams) (*Range, error) {
	row := q.db.QueryRow(ctx, createRange,
		arg.StartID,
		arg.EndID,
		arg.ServiceID,
		arg.Region,
		arg.Status,
	)
	var i Range
	err := row.Scan(
		&i.RangeID,
		&i.StartID,
		&i.EndID,
		&i.ServiceID,
		&i.Region,
		&i.Status,
		&i.AllocatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteRange = `-- name: DeleteRange :exec
DELETE FROM ranges
WHERE range_id = $1
AND service_id = $2
`

type DeleteRangeParams struct {
	RangeID   uuid.UUID `json:"range_id"`
	ServiceID string    `json:"service_id"`
}

// Deletes a range (for testing purposes)
func (q *Queries) DeleteRange(ctx context.Context, arg DeleteRangeParams) error {
	_, err := q.db.Exec(ctx, deleteRange, arg.RangeID, arg.ServiceID)
	return err
}

const getLastRangeForService = `-- name: GetLastRangeForService :one
SELECT range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at FROM ranges
WHERE service_id = $1 
AND region = $2
ORDER BY end_id DESC
LIMIT 1
`

type GetLastRangeForServiceParams struct {
	ServiceID string      `json:"service_id"`
	Region    pgtype.Text `json:"region"`
}

// Gets the last allocated range for a service in a specific region
func (q *Queries) GetLastRangeForService(ctx context.Context, arg GetLastRangeForServiceParams) (*Range, error) {
	row := q.db.QueryRow(ctx, getLastRangeForService, arg.ServiceID, arg.Region)
	var i Range
	err := row.Scan(
		&i.RangeID,
		&i.StartID,
		&i.EndID,
		&i.ServiceID,
		&i.Region,
		&i.Status,
		&i.AllocatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRange = `-- name: GetRange :one
SELECT range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at FROM ranges
WHERE range_id = $1
`

// Gets a range by its ID
func (q *Queries) GetRange(ctx context.Context, rangeID uuid.UUID) (*Range, error) {
	row := q.db.QueryRow(ctx, getRange, rangeID)
	var i Range
	err := row.Scan(
		&i.RangeID,
		&i.StartID,
		&i.EndID,
		&i.ServiceID,
		&i.Region,
		&i.Status,
		&i.AllocatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRangesByStatus = `-- name: GetRangesByStatus :many
SELECT range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at FROM ranges
WHERE status = $1
ORDER BY range_id
LIMIT $2 OFFSET $3
`

type GetRangesByStatusParams struct {
	Status RangeStatus `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

// Gets ranges by status
func (q *Queries) GetRangesByStatus(ctx context.Context, arg GetRangesByStatusParams) ([]*Range, error) {
	rows, err := q.db.Query(ctx, getRangesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Range{}
	for rows.Next() {
		var i Range
		if err := rows.Scan(
			&i.RangeID,
			&i.StartID,
			&i.EndID,
			&i.ServiceID,
			&i.Region,
			&i.Status,
			&i.AllocatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceRanges = `-- name: GetServiceRanges :many
SELECT range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at FROM ranges
WHERE service_id = $1 
AND region = $2
ORDER BY start_id
`

type GetServiceRangesParams struct {
	ServiceID string      `json:"service_id"`
	Region    pgtype.Text `json:"region"`
}

// Gets all ranges for a service in a specific region
func (q *Queries) GetServiceRanges(ctx context.Context, arg GetServiceRangesParams) ([]*Range, error) {
	rows, err := q.db.Query(ctx, getServiceRanges, arg.ServiceID, arg.Region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Range{}
	for rows.Next() {
		var i Range
		if err := rows.Scan(
			&i.RangeID,
			&i.StartID,
			&i.EndID,
			&i.ServiceID,
			&i.Region,
			&i.Status,
			&i.AllocatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRanges = `-- name: ListRanges :many
SELECT range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at FROM ranges
WHERE service_id = $1
    AND ($3::range_status IS NULL OR status = $3::range_status)
    AND ($4::text IS NULL OR region = $4)
    AND ($5::uuid IS NULL OR range_id > $5)
ORDER BY range_id
LIMIT $2
`

type ListRangesParams struct {
	ServiceID    string          `json:"service_id"`
	Limit        int32           `json:"limit"`
	StatusFilter NullRangeStatus `json:"status_filter"`
	RegionFilter pgtype.Text     `json:"region_filter"`
	CursorID     pgtype.UUID     `json:"cursor_id"`
}

// Lists ranges for a service with optional filters
func (q *Queries) ListRanges(ctx context.Context, arg ListRangesParams) ([]*Range, error) {
	rows, err := q.db.Query(ctx, listRanges,
		arg.ServiceID,
		arg.Limit,
		arg.StatusFilter,
		arg.RegionFilter,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Range{}
	for rows.Next() {
		var i Range
		if err := rows.Scan(
			&i.RangeID,
			&i.StartID,
			&i.EndID,
			&i.ServiceID,
			&i.Region,
			&i.Status,
			&i.AllocatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRangeStatus = `-- name: UpdateRangeStatus :one
UPDATE ranges
SET status = $3
WHERE range_id = $1 
AND service_id = $2
RETURNING range_id, start_id, end_id, service_id, region, status, allocated_at, updated_at
`

type UpdateRangeStatusParams struct {
	RangeID   uuid.UUID   `json:"range_id"`
	ServiceID string      `json:"service_id"`
	Status    RangeStatus `json:"status"`
}

// Updates the status of a range
func (q *Queries) UpdateRangeStatus(ctx context.Context, arg UpdateRangeStatusParams) (*Range, error) {
	row := q.db.QueryRow(ctx, updateRangeStatus, arg.RangeID, arg.ServiceID, arg.Status)
	var i Range
	err := row.Scan(
		&i.RangeID,
		&i.StartID,
		&i.EndID,
		&i.ServiceID,
		&i.Region,
		&i.Status,
		&i.AllocatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
